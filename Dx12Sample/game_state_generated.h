// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GAMESTATE_NETSIM_H_
#define FLATBUFFERS_GENERATED_GAMESTATE_NETSIM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace NetSim {

struct Vec3;

struct Vec4;

struct PhysicsMaterial;

struct ObjectState;
struct ObjectStateBuilder;

struct Scenario;
struct ScenarioBuilder;

struct Recognize;
struct RecognizeBuilder;

struct ObjectUpdate;
struct ObjectUpdateBuilder;

struct ObjectUpdateList;
struct ObjectUpdateListBuilder;

struct PeerInfo;
struct PeerInfoBuilder;

struct PeerList;
struct PeerListBuilder;

struct RequestScenario;
struct RequestScenarioBuilder;

struct Ping;
struct PingBuilder;

struct Pong;
struct PongBuilder;

struct StartSimulation;
struct StartSimulationBuilder;

struct DiscoveryBroadcast;
struct DiscoveryBroadcastBuilder;

struct NetworkMessage;
struct NetworkMessageBuilder;

enum MeshType : uint8_t {
  MeshType_Sphere = 0,
  MeshType_Box = 1,
  MeshType_Capsule = 2,
  MeshType_Plane = 3,
  MeshType_MIN = MeshType_Sphere,
  MeshType_MAX = MeshType_Plane
};

inline const MeshType (&EnumValuesMeshType())[4] {
  static const MeshType values[] = {
    MeshType_Sphere,
    MeshType_Box,
    MeshType_Capsule,
    MeshType_Plane
  };
  return values;
}

inline const char * const *EnumNamesMeshType() {
  static const char * const names[5] = {
    "Sphere",
    "Box",
    "Capsule",
    "Plane",
    nullptr
  };
  return names;
}

inline const char *EnumNameMeshType(MeshType e) {
  if (::flatbuffers::IsOutRange(e, MeshType_Sphere, MeshType_Plane)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMeshType()[index];
}

enum MessageUnion : uint8_t {
  MessageUnion_NONE = 0,
  MessageUnion_Recognize = 1,
  MessageUnion_Scenario = 2,
  MessageUnion_ObjectUpdateList = 3,
  MessageUnion_RequestScenario = 4,
  MessageUnion_StartSimulation = 5,
  MessageUnion_PeerList = 6,
  MessageUnion_Ping = 7,
  MessageUnion_Pong = 8,
  MessageUnion_DiscoveryBroadcast = 9,
  MessageUnion_MIN = MessageUnion_NONE,
  MessageUnion_MAX = MessageUnion_DiscoveryBroadcast
};

inline const MessageUnion (&EnumValuesMessageUnion())[10] {
  static const MessageUnion values[] = {
    MessageUnion_NONE,
    MessageUnion_Recognize,
    MessageUnion_Scenario,
    MessageUnion_ObjectUpdateList,
    MessageUnion_RequestScenario,
    MessageUnion_StartSimulation,
    MessageUnion_PeerList,
    MessageUnion_Ping,
    MessageUnion_Pong,
    MessageUnion_DiscoveryBroadcast
  };
  return values;
}

inline const char * const *EnumNamesMessageUnion() {
  static const char * const names[11] = {
    "NONE",
    "Recognize",
    "Scenario",
    "ObjectUpdateList",
    "RequestScenario",
    "StartSimulation",
    "PeerList",
    "Ping",
    "Pong",
    "DiscoveryBroadcast",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageUnion(MessageUnion e) {
  if (::flatbuffers::IsOutRange(e, MessageUnion_NONE, MessageUnion_DiscoveryBroadcast)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageUnion()[index];
}

template<typename T> struct MessageUnionTraits {
  static const MessageUnion enum_value = MessageUnion_NONE;
};

template<> struct MessageUnionTraits<NetSim::Recognize> {
  static const MessageUnion enum_value = MessageUnion_Recognize;
};

template<> struct MessageUnionTraits<NetSim::Scenario> {
  static const MessageUnion enum_value = MessageUnion_Scenario;
};

template<> struct MessageUnionTraits<NetSim::ObjectUpdateList> {
  static const MessageUnion enum_value = MessageUnion_ObjectUpdateList;
};

template<> struct MessageUnionTraits<NetSim::RequestScenario> {
  static const MessageUnion enum_value = MessageUnion_RequestScenario;
};

template<> struct MessageUnionTraits<NetSim::StartSimulation> {
  static const MessageUnion enum_value = MessageUnion_StartSimulation;
};

template<> struct MessageUnionTraits<NetSim::PeerList> {
  static const MessageUnion enum_value = MessageUnion_PeerList;
};

template<> struct MessageUnionTraits<NetSim::Ping> {
  static const MessageUnion enum_value = MessageUnion_Ping;
};

template<> struct MessageUnionTraits<NetSim::Pong> {
  static const MessageUnion enum_value = MessageUnion_Pong;
};

template<> struct MessageUnionTraits<NetSim::DiscoveryBroadcast> {
  static const MessageUnion enum_value = MessageUnion_DiscoveryBroadcast;
};

bool VerifyMessageUnion(::flatbuffers::Verifier &verifier, const void *obj, MessageUnion type);
bool VerifyMessageUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        w_(::flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) PhysicsMaterial FLATBUFFERS_FINAL_CLASS {
 private:
  float friction_;
  float angular_friction_;
  float restitution_;

 public:
  PhysicsMaterial()
      : friction_(0),
        angular_friction_(0),
        restitution_(0) {
  }
  PhysicsMaterial(float _friction, float _angular_friction, float _restitution)
      : friction_(::flatbuffers::EndianScalar(_friction)),
        angular_friction_(::flatbuffers::EndianScalar(_angular_friction)),
        restitution_(::flatbuffers::EndianScalar(_restitution)) {
  }
  float friction() const {
    return ::flatbuffers::EndianScalar(friction_);
  }
  float angular_friction() const {
    return ::flatbuffers::EndianScalar(angular_friction_);
  }
  float restitution() const {
    return ::flatbuffers::EndianScalar(restitution_);
  }
};
FLATBUFFERS_STRUCT_END(PhysicsMaterial, 12);

struct ObjectState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_IS_STATIC = 6,
    VT_TYPE = 8,
    VT_MATERIAL = 10,
    VT_COLLIDER_SIZE = 12,
    VT_POSITION = 14,
    VT_ROTATION = 16,
    VT_SCALE = 18,
    VT_COLOR = 20,
    VT_AUTHORITY_PEER_ID = 22
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool is_static() const {
    return GetField<uint8_t>(VT_IS_STATIC, 0) != 0;
  }
  NetSim::MeshType type() const {
    return static_cast<NetSim::MeshType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const NetSim::PhysicsMaterial *material() const {
    return GetStruct<const NetSim::PhysicsMaterial *>(VT_MATERIAL);
  }
  const NetSim::Vec3 *collider_size() const {
    return GetStruct<const NetSim::Vec3 *>(VT_COLLIDER_SIZE);
  }
  const NetSim::Vec3 *position() const {
    return GetStruct<const NetSim::Vec3 *>(VT_POSITION);
  }
  const NetSim::Vec4 *rotation() const {
    return GetStruct<const NetSim::Vec4 *>(VT_ROTATION);
  }
  const NetSim::Vec3 *scale() const {
    return GetStruct<const NetSim::Vec3 *>(VT_SCALE);
  }
  const NetSim::Vec3 *color() const {
    return GetStruct<const NetSim::Vec3 *>(VT_COLOR);
  }
  uint32_t authority_peer_id() const {
    return GetField<uint32_t>(VT_AUTHORITY_PEER_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_STATIC, 1) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<NetSim::PhysicsMaterial>(verifier, VT_MATERIAL, 4) &&
           VerifyField<NetSim::Vec3>(verifier, VT_COLLIDER_SIZE, 4) &&
           VerifyField<NetSim::Vec3>(verifier, VT_POSITION, 4) &&
           VerifyField<NetSim::Vec4>(verifier, VT_ROTATION, 4) &&
           VerifyField<NetSim::Vec3>(verifier, VT_SCALE, 4) &&
           VerifyField<NetSim::Vec3>(verifier, VT_COLOR, 4) &&
           VerifyField<uint32_t>(verifier, VT_AUTHORITY_PEER_ID, 4) &&
           verifier.EndTable();
  }
};

struct ObjectStateBuilder {
  typedef ObjectState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(ObjectState::VT_ID, id, 0);
  }
  void add_is_static(bool is_static) {
    fbb_.AddElement<uint8_t>(ObjectState::VT_IS_STATIC, static_cast<uint8_t>(is_static), 0);
  }
  void add_type(NetSim::MeshType type) {
    fbb_.AddElement<uint8_t>(ObjectState::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_material(const NetSim::PhysicsMaterial *material) {
    fbb_.AddStruct(ObjectState::VT_MATERIAL, material);
  }
  void add_collider_size(const NetSim::Vec3 *collider_size) {
    fbb_.AddStruct(ObjectState::VT_COLLIDER_SIZE, collider_size);
  }
  void add_position(const NetSim::Vec3 *position) {
    fbb_.AddStruct(ObjectState::VT_POSITION, position);
  }
  void add_rotation(const NetSim::Vec4 *rotation) {
    fbb_.AddStruct(ObjectState::VT_ROTATION, rotation);
  }
  void add_scale(const NetSim::Vec3 *scale) {
    fbb_.AddStruct(ObjectState::VT_SCALE, scale);
  }
  void add_color(const NetSim::Vec3 *color) {
    fbb_.AddStruct(ObjectState::VT_COLOR, color);
  }
  void add_authority_peer_id(uint32_t authority_peer_id) {
    fbb_.AddElement<uint32_t>(ObjectState::VT_AUTHORITY_PEER_ID, authority_peer_id, 0);
  }
  explicit ObjectStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectState> CreateObjectState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    bool is_static = false,
    NetSim::MeshType type = NetSim::MeshType_Sphere,
    const NetSim::PhysicsMaterial *material = nullptr,
    const NetSim::Vec3 *collider_size = nullptr,
    const NetSim::Vec3 *position = nullptr,
    const NetSim::Vec4 *rotation = nullptr,
    const NetSim::Vec3 *scale = nullptr,
    const NetSim::Vec3 *color = nullptr,
    uint32_t authority_peer_id = 0) {
  ObjectStateBuilder builder_(_fbb);
  builder_.add_authority_peer_id(authority_peer_id);
  builder_.add_color(color);
  builder_.add_scale(scale);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  builder_.add_collider_size(collider_size);
  builder_.add_material(material);
  builder_.add_id(id);
  builder_.add_type(type);
  builder_.add_is_static(is_static);
  return builder_.Finish();
}

struct Scenario FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScenarioBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCENARIO_ID = 4,
    VT_OBJECTS = 6,
    VT_GRAVITY = 8
  };
  uint32_t scenario_id() const {
    return GetField<uint32_t>(VT_SCENARIO_ID, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NetSim::ObjectState>> *objects() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NetSim::ObjectState>> *>(VT_OBJECTS);
  }
  float gravity() const {
    return GetField<float>(VT_GRAVITY, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SCENARIO_ID, 4) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.VerifyVector(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           VerifyField<float>(verifier, VT_GRAVITY, 4) &&
           verifier.EndTable();
  }
};

struct ScenarioBuilder {
  typedef Scenario Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_scenario_id(uint32_t scenario_id) {
    fbb_.AddElement<uint32_t>(Scenario::VT_SCENARIO_ID, scenario_id, 0);
  }
  void add_objects(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetSim::ObjectState>>> objects) {
    fbb_.AddOffset(Scenario::VT_OBJECTS, objects);
  }
  void add_gravity(float gravity) {
    fbb_.AddElement<float>(Scenario::VT_GRAVITY, gravity, 0.0f);
  }
  explicit ScenarioBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Scenario> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Scenario>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Scenario> CreateScenario(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t scenario_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetSim::ObjectState>>> objects = 0,
    float gravity = 0.0f) {
  ScenarioBuilder builder_(_fbb);
  builder_.add_gravity(gravity);
  builder_.add_objects(objects);
  builder_.add_scenario_id(scenario_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Scenario> CreateScenarioDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t scenario_id = 0,
    const std::vector<::flatbuffers::Offset<NetSim::ObjectState>> *objects = nullptr,
    float gravity = 0.0f) {
  auto objects__ = objects ? _fbb.CreateVector<::flatbuffers::Offset<NetSim::ObjectState>>(*objects) : 0;
  return NetSim::CreateScenario(
      _fbb,
      scenario_id,
      objects__,
      gravity);
}

struct Recognize FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RecognizeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOL_VERSION = 4,
    VT_PEER_ID = 6,
    VT_CLIENT_NAME = 8,
    VT_LISTEN_PORT = 10,
    VT_COLOR = 12
  };
  uint32_t protocol_version() const {
    return GetField<uint32_t>(VT_PROTOCOL_VERSION, 0);
  }
  uint32_t peer_id() const {
    return GetField<uint32_t>(VT_PEER_ID, 0);
  }
  const ::flatbuffers::String *client_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_NAME);
  }
  uint16_t listen_port() const {
    return GetField<uint16_t>(VT_LISTEN_PORT, 0);
  }
  const NetSim::Vec3 *color() const {
    return GetStruct<const NetSim::Vec3 *>(VT_COLOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PROTOCOL_VERSION, 4) &&
           VerifyField<uint32_t>(verifier, VT_PEER_ID, 4) &&
           VerifyOffset(verifier, VT_CLIENT_NAME) &&
           verifier.VerifyString(client_name()) &&
           VerifyField<uint16_t>(verifier, VT_LISTEN_PORT, 2) &&
           VerifyField<NetSim::Vec3>(verifier, VT_COLOR, 4) &&
           verifier.EndTable();
  }
};

struct RecognizeBuilder {
  typedef Recognize Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_protocol_version(uint32_t protocol_version) {
    fbb_.AddElement<uint32_t>(Recognize::VT_PROTOCOL_VERSION, protocol_version, 0);
  }
  void add_peer_id(uint32_t peer_id) {
    fbb_.AddElement<uint32_t>(Recognize::VT_PEER_ID, peer_id, 0);
  }
  void add_client_name(::flatbuffers::Offset<::flatbuffers::String> client_name) {
    fbb_.AddOffset(Recognize::VT_CLIENT_NAME, client_name);
  }
  void add_listen_port(uint16_t listen_port) {
    fbb_.AddElement<uint16_t>(Recognize::VT_LISTEN_PORT, listen_port, 0);
  }
  void add_color(const NetSim::Vec3 *color) {
    fbb_.AddStruct(Recognize::VT_COLOR, color);
  }
  explicit RecognizeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Recognize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Recognize>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Recognize> CreateRecognize(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t protocol_version = 0,
    uint32_t peer_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> client_name = 0,
    uint16_t listen_port = 0,
    const NetSim::Vec3 *color = nullptr) {
  RecognizeBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_client_name(client_name);
  builder_.add_peer_id(peer_id);
  builder_.add_protocol_version(protocol_version);
  builder_.add_listen_port(listen_port);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Recognize> CreateRecognizeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t protocol_version = 0,
    uint32_t peer_id = 0,
    const char *client_name = nullptr,
    uint16_t listen_port = 0,
    const NetSim::Vec3 *color = nullptr) {
  auto client_name__ = client_name ? _fbb.CreateString(client_name) : 0;
  return NetSim::CreateRecognize(
      _fbb,
      protocol_version,
      peer_id,
      client_name__,
      listen_port,
      color);
}

struct ObjectUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_ID = 4,
    VT_POSITION = 6,
    VT_ROTATION = 8,
    VT_VELOCITY = 10,
    VT_ANGULAR_VELOCITY = 12
  };
  uint32_t object_id() const {
    return GetField<uint32_t>(VT_OBJECT_ID, 0);
  }
  const NetSim::Vec3 *position() const {
    return GetStruct<const NetSim::Vec3 *>(VT_POSITION);
  }
  const NetSim::Vec4 *rotation() const {
    return GetStruct<const NetSim::Vec4 *>(VT_ROTATION);
  }
  const NetSim::Vec3 *velocity() const {
    return GetStruct<const NetSim::Vec3 *>(VT_VELOCITY);
  }
  const NetSim::Vec3 *angular_velocity() const {
    return GetStruct<const NetSim::Vec3 *>(VT_ANGULAR_VELOCITY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OBJECT_ID, 4) &&
           VerifyField<NetSim::Vec3>(verifier, VT_POSITION, 4) &&
           VerifyField<NetSim::Vec4>(verifier, VT_ROTATION, 4) &&
           VerifyField<NetSim::Vec3>(verifier, VT_VELOCITY, 4) &&
           VerifyField<NetSim::Vec3>(verifier, VT_ANGULAR_VELOCITY, 4) &&
           verifier.EndTable();
  }
};

struct ObjectUpdateBuilder {
  typedef ObjectUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_object_id(uint32_t object_id) {
    fbb_.AddElement<uint32_t>(ObjectUpdate::VT_OBJECT_ID, object_id, 0);
  }
  void add_position(const NetSim::Vec3 *position) {
    fbb_.AddStruct(ObjectUpdate::VT_POSITION, position);
  }
  void add_rotation(const NetSim::Vec4 *rotation) {
    fbb_.AddStruct(ObjectUpdate::VT_ROTATION, rotation);
  }
  void add_velocity(const NetSim::Vec3 *velocity) {
    fbb_.AddStruct(ObjectUpdate::VT_VELOCITY, velocity);
  }
  void add_angular_velocity(const NetSim::Vec3 *angular_velocity) {
    fbb_.AddStruct(ObjectUpdate::VT_ANGULAR_VELOCITY, angular_velocity);
  }
  explicit ObjectUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectUpdate> CreateObjectUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t object_id = 0,
    const NetSim::Vec3 *position = nullptr,
    const NetSim::Vec4 *rotation = nullptr,
    const NetSim::Vec3 *velocity = nullptr,
    const NetSim::Vec3 *angular_velocity = nullptr) {
  ObjectUpdateBuilder builder_(_fbb);
  builder_.add_angular_velocity(angular_velocity);
  builder_.add_velocity(velocity);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  builder_.add_object_id(object_id);
  return builder_.Finish();
}

struct ObjectUpdateList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectUpdateListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NetSim::ObjectUpdate>> *updates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NetSim::ObjectUpdate>> *>(VT_UPDATES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UPDATES) &&
           verifier.VerifyVector(updates()) &&
           verifier.VerifyVectorOfTables(updates()) &&
           verifier.EndTable();
  }
};

struct ObjectUpdateListBuilder {
  typedef ObjectUpdateList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_updates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetSim::ObjectUpdate>>> updates) {
    fbb_.AddOffset(ObjectUpdateList::VT_UPDATES, updates);
  }
  explicit ObjectUpdateListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectUpdateList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectUpdateList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectUpdateList> CreateObjectUpdateList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetSim::ObjectUpdate>>> updates = 0) {
  ObjectUpdateListBuilder builder_(_fbb);
  builder_.add_updates(updates);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ObjectUpdateList> CreateObjectUpdateListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NetSim::ObjectUpdate>> *updates = nullptr) {
  auto updates__ = updates ? _fbb.CreateVector<::flatbuffers::Offset<NetSim::ObjectUpdate>>(*updates) : 0;
  return NetSim::CreateObjectUpdateList(
      _fbb,
      updates__);
}

struct PeerInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PeerInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEER_ID = 4,
    VT_IP = 6,
    VT_PORT = 8,
    VT_COLOR = 10
  };
  uint32_t peer_id() const {
    return GetField<uint32_t>(VT_PEER_ID, 0);
  }
  const ::flatbuffers::String *ip() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IP);
  }
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  const NetSim::Vec3 *color() const {
    return GetStruct<const NetSim::Vec3 *>(VT_COLOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PEER_ID, 4) &&
           VerifyOffset(verifier, VT_IP) &&
           verifier.VerifyString(ip()) &&
           VerifyField<uint16_t>(verifier, VT_PORT, 2) &&
           VerifyField<NetSim::Vec3>(verifier, VT_COLOR, 4) &&
           verifier.EndTable();
  }
};

struct PeerInfoBuilder {
  typedef PeerInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_peer_id(uint32_t peer_id) {
    fbb_.AddElement<uint32_t>(PeerInfo::VT_PEER_ID, peer_id, 0);
  }
  void add_ip(::flatbuffers::Offset<::flatbuffers::String> ip) {
    fbb_.AddOffset(PeerInfo::VT_IP, ip);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(PeerInfo::VT_PORT, port, 0);
  }
  void add_color(const NetSim::Vec3 *color) {
    fbb_.AddStruct(PeerInfo::VT_COLOR, color);
  }
  explicit PeerInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PeerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PeerInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PeerInfo> CreatePeerInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t peer_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ip = 0,
    uint16_t port = 0,
    const NetSim::Vec3 *color = nullptr) {
  PeerInfoBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_ip(ip);
  builder_.add_peer_id(peer_id);
  builder_.add_port(port);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PeerInfo> CreatePeerInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t peer_id = 0,
    const char *ip = nullptr,
    uint16_t port = 0,
    const NetSim::Vec3 *color = nullptr) {
  auto ip__ = ip ? _fbb.CreateString(ip) : 0;
  return NetSim::CreatePeerInfo(
      _fbb,
      peer_id,
      ip__,
      port,
      color);
}

struct PeerList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PeerListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEERS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NetSim::PeerInfo>> *peers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NetSim::PeerInfo>> *>(VT_PEERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PEERS) &&
           verifier.VerifyVector(peers()) &&
           verifier.VerifyVectorOfTables(peers()) &&
           verifier.EndTable();
  }
};

struct PeerListBuilder {
  typedef PeerList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_peers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetSim::PeerInfo>>> peers) {
    fbb_.AddOffset(PeerList::VT_PEERS, peers);
  }
  explicit PeerListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PeerList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PeerList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PeerList> CreatePeerList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetSim::PeerInfo>>> peers = 0) {
  PeerListBuilder builder_(_fbb);
  builder_.add_peers(peers);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PeerList> CreatePeerListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NetSim::PeerInfo>> *peers = nullptr) {
  auto peers__ = peers ? _fbb.CreateVector<::flatbuffers::Offset<NetSim::PeerInfo>>(*peers) : 0;
  return NetSim::CreatePeerList(
      _fbb,
      peers__);
}

struct RequestScenario FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestScenarioBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DUMMY = 4
  };
  bool dummy() const {
    return GetField<uint8_t>(VT_DUMMY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DUMMY, 1) &&
           verifier.EndTable();
  }
};

struct RequestScenarioBuilder {
  typedef RequestScenario Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dummy(bool dummy) {
    fbb_.AddElement<uint8_t>(RequestScenario::VT_DUMMY, static_cast<uint8_t>(dummy), 0);
  }
  explicit RequestScenarioBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestScenario> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestScenario>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestScenario> CreateRequestScenario(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool dummy = false) {
  RequestScenarioBuilder builder_(_fbb);
  builder_.add_dummy(dummy);
  return builder_.Finish();
}

struct Ping FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENT_TIME = 4
  };
  double sent_time() const {
    return GetField<double>(VT_SENT_TIME, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SENT_TIME, 8) &&
           verifier.EndTable();
  }
};

struct PingBuilder {
  typedef Ping Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sent_time(double sent_time) {
    fbb_.AddElement<double>(Ping::VT_SENT_TIME, sent_time, 0.0);
  }
  explicit PingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Ping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Ping>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Ping> CreatePing(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double sent_time = 0.0) {
  PingBuilder builder_(_fbb);
  builder_.add_sent_time(sent_time);
  return builder_.Finish();
}

struct Pong FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PongBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PING_SENT_TIME = 4,
    VT_REMOTE_TIME = 6
  };
  double ping_sent_time() const {
    return GetField<double>(VT_PING_SENT_TIME, 0.0);
  }
  double remote_time() const {
    return GetField<double>(VT_REMOTE_TIME, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_PING_SENT_TIME, 8) &&
           VerifyField<double>(verifier, VT_REMOTE_TIME, 8) &&
           verifier.EndTable();
  }
};

struct PongBuilder {
  typedef Pong Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ping_sent_time(double ping_sent_time) {
    fbb_.AddElement<double>(Pong::VT_PING_SENT_TIME, ping_sent_time, 0.0);
  }
  void add_remote_time(double remote_time) {
    fbb_.AddElement<double>(Pong::VT_REMOTE_TIME, remote_time, 0.0);
  }
  explicit PongBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pong> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pong>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pong> CreatePong(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double ping_sent_time = 0.0,
    double remote_time = 0.0) {
  PongBuilder builder_(_fbb);
  builder_.add_remote_time(remote_time);
  builder_.add_ping_sent_time(ping_sent_time);
  return builder_.Finish();
}

struct StartSimulation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StartSimulationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIMULATION_START_TIME = 4
  };
  double simulation_start_time() const {
    return GetField<double>(VT_SIMULATION_START_TIME, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SIMULATION_START_TIME, 8) &&
           verifier.EndTable();
  }
};

struct StartSimulationBuilder {
  typedef StartSimulation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_simulation_start_time(double simulation_start_time) {
    fbb_.AddElement<double>(StartSimulation::VT_SIMULATION_START_TIME, simulation_start_time, 0.0);
  }
  explicit StartSimulationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StartSimulation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StartSimulation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StartSimulation> CreateStartSimulation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double simulation_start_time = 0.0) {
  StartSimulationBuilder builder_(_fbb);
  builder_.add_simulation_start_time(simulation_start_time);
  return builder_.Finish();
}

struct DiscoveryBroadcast FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DiscoveryBroadcastBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOL_VERSION = 4,
    VT_PEER_ID = 6,
    VT_CLIENT_NAME = 8,
    VT_TCP_PORT = 10,
    VT_COLOR = 12
  };
  uint32_t protocol_version() const {
    return GetField<uint32_t>(VT_PROTOCOL_VERSION, 0);
  }
  uint32_t peer_id() const {
    return GetField<uint32_t>(VT_PEER_ID, 0);
  }
  const ::flatbuffers::String *client_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_NAME);
  }
  uint16_t tcp_port() const {
    return GetField<uint16_t>(VT_TCP_PORT, 0);
  }
  const NetSim::Vec3 *color() const {
    return GetStruct<const NetSim::Vec3 *>(VT_COLOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PROTOCOL_VERSION, 4) &&
           VerifyField<uint32_t>(verifier, VT_PEER_ID, 4) &&
           VerifyOffset(verifier, VT_CLIENT_NAME) &&
           verifier.VerifyString(client_name()) &&
           VerifyField<uint16_t>(verifier, VT_TCP_PORT, 2) &&
           VerifyField<NetSim::Vec3>(verifier, VT_COLOR, 4) &&
           verifier.EndTable();
  }
};

struct DiscoveryBroadcastBuilder {
  typedef DiscoveryBroadcast Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_protocol_version(uint32_t protocol_version) {
    fbb_.AddElement<uint32_t>(DiscoveryBroadcast::VT_PROTOCOL_VERSION, protocol_version, 0);
  }
  void add_peer_id(uint32_t peer_id) {
    fbb_.AddElement<uint32_t>(DiscoveryBroadcast::VT_PEER_ID, peer_id, 0);
  }
  void add_client_name(::flatbuffers::Offset<::flatbuffers::String> client_name) {
    fbb_.AddOffset(DiscoveryBroadcast::VT_CLIENT_NAME, client_name);
  }
  void add_tcp_port(uint16_t tcp_port) {
    fbb_.AddElement<uint16_t>(DiscoveryBroadcast::VT_TCP_PORT, tcp_port, 0);
  }
  void add_color(const NetSim::Vec3 *color) {
    fbb_.AddStruct(DiscoveryBroadcast::VT_COLOR, color);
  }
  explicit DiscoveryBroadcastBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DiscoveryBroadcast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DiscoveryBroadcast>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DiscoveryBroadcast> CreateDiscoveryBroadcast(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t protocol_version = 0,
    uint32_t peer_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> client_name = 0,
    uint16_t tcp_port = 0,
    const NetSim::Vec3 *color = nullptr) {
  DiscoveryBroadcastBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_client_name(client_name);
  builder_.add_peer_id(peer_id);
  builder_.add_protocol_version(protocol_version);
  builder_.add_tcp_port(tcp_port);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DiscoveryBroadcast> CreateDiscoveryBroadcastDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t protocol_version = 0,
    uint32_t peer_id = 0,
    const char *client_name = nullptr,
    uint16_t tcp_port = 0,
    const NetSim::Vec3 *color = nullptr) {
  auto client_name__ = client_name ? _fbb.CreateString(client_name) : 0;
  return NetSim::CreateDiscoveryBroadcast(
      _fbb,
      protocol_version,
      peer_id,
      client_name__,
      tcp_port,
      color);
}

struct NetworkMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetworkMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_TYPE = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  const ::flatbuffers::String *msg_type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSG_TYPE);
  }
  NetSim::MessageUnion data_type() const {
    return static_cast<NetSim::MessageUnion>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const NetSim::Recognize *data_as_Recognize() const {
    return data_type() == NetSim::MessageUnion_Recognize ? static_cast<const NetSim::Recognize *>(data()) : nullptr;
  }
  const NetSim::Scenario *data_as_Scenario() const {
    return data_type() == NetSim::MessageUnion_Scenario ? static_cast<const NetSim::Scenario *>(data()) : nullptr;
  }
  const NetSim::ObjectUpdateList *data_as_ObjectUpdateList() const {
    return data_type() == NetSim::MessageUnion_ObjectUpdateList ? static_cast<const NetSim::ObjectUpdateList *>(data()) : nullptr;
  }
  const NetSim::RequestScenario *data_as_RequestScenario() const {
    return data_type() == NetSim::MessageUnion_RequestScenario ? static_cast<const NetSim::RequestScenario *>(data()) : nullptr;
  }
  const NetSim::StartSimulation *data_as_StartSimulation() const {
    return data_type() == NetSim::MessageUnion_StartSimulation ? static_cast<const NetSim::StartSimulation *>(data()) : nullptr;
  }
  const NetSim::PeerList *data_as_PeerList() const {
    return data_type() == NetSim::MessageUnion_PeerList ? static_cast<const NetSim::PeerList *>(data()) : nullptr;
  }
  const NetSim::Ping *data_as_Ping() const {
    return data_type() == NetSim::MessageUnion_Ping ? static_cast<const NetSim::Ping *>(data()) : nullptr;
  }
  const NetSim::Pong *data_as_Pong() const {
    return data_type() == NetSim::MessageUnion_Pong ? static_cast<const NetSim::Pong *>(data()) : nullptr;
  }
  const NetSim::DiscoveryBroadcast *data_as_DiscoveryBroadcast() const {
    return data_type() == NetSim::MessageUnion_DiscoveryBroadcast ? static_cast<const NetSim::DiscoveryBroadcast *>(data()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MSG_TYPE) &&
           verifier.VerifyString(msg_type()) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyMessageUnion(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const NetSim::Recognize *NetworkMessage::data_as<NetSim::Recognize>() const {
  return data_as_Recognize();
}

template<> inline const NetSim::Scenario *NetworkMessage::data_as<NetSim::Scenario>() const {
  return data_as_Scenario();
}

template<> inline const NetSim::ObjectUpdateList *NetworkMessage::data_as<NetSim::ObjectUpdateList>() const {
  return data_as_ObjectUpdateList();
}

template<> inline const NetSim::RequestScenario *NetworkMessage::data_as<NetSim::RequestScenario>() const {
  return data_as_RequestScenario();
}

template<> inline const NetSim::StartSimulation *NetworkMessage::data_as<NetSim::StartSimulation>() const {
  return data_as_StartSimulation();
}

template<> inline const NetSim::PeerList *NetworkMessage::data_as<NetSim::PeerList>() const {
  return data_as_PeerList();
}

template<> inline const NetSim::Ping *NetworkMessage::data_as<NetSim::Ping>() const {
  return data_as_Ping();
}

template<> inline const NetSim::Pong *NetworkMessage::data_as<NetSim::Pong>() const {
  return data_as_Pong();
}

template<> inline const NetSim::DiscoveryBroadcast *NetworkMessage::data_as<NetSim::DiscoveryBroadcast>() const {
  return data_as_DiscoveryBroadcast();
}

struct NetworkMessageBuilder {
  typedef NetworkMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg_type(::flatbuffers::Offset<::flatbuffers::String> msg_type) {
    fbb_.AddOffset(NetworkMessage::VT_MSG_TYPE, msg_type);
  }
  void add_data_type(NetSim::MessageUnion data_type) {
    fbb_.AddElement<uint8_t>(NetworkMessage::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(NetworkMessage::VT_DATA, data);
  }
  explicit NetworkMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetworkMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetworkMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetworkMessage> CreateNetworkMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> msg_type = 0,
    NetSim::MessageUnion data_type = NetSim::MessageUnion_NONE,
    ::flatbuffers::Offset<void> data = 0) {
  NetworkMessageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_msg_type(msg_type);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetworkMessage> CreateNetworkMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *msg_type = nullptr,
    NetSim::MessageUnion data_type = NetSim::MessageUnion_NONE,
    ::flatbuffers::Offset<void> data = 0) {
  auto msg_type__ = msg_type ? _fbb.CreateString(msg_type) : 0;
  return NetSim::CreateNetworkMessage(
      _fbb,
      msg_type__,
      data_type,
      data);
}

inline bool VerifyMessageUnion(::flatbuffers::Verifier &verifier, const void *obj, MessageUnion type) {
  switch (type) {
    case MessageUnion_NONE: {
      return true;
    }
    case MessageUnion_Recognize: {
      auto ptr = reinterpret_cast<const NetSim::Recognize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageUnion_Scenario: {
      auto ptr = reinterpret_cast<const NetSim::Scenario *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageUnion_ObjectUpdateList: {
      auto ptr = reinterpret_cast<const NetSim::ObjectUpdateList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageUnion_RequestScenario: {
      auto ptr = reinterpret_cast<const NetSim::RequestScenario *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageUnion_StartSimulation: {
      auto ptr = reinterpret_cast<const NetSim::StartSimulation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageUnion_PeerList: {
      auto ptr = reinterpret_cast<const NetSim::PeerList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageUnion_Ping: {
      auto ptr = reinterpret_cast<const NetSim::Ping *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageUnion_Pong: {
      auto ptr = reinterpret_cast<const NetSim::Pong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageUnion_DiscoveryBroadcast: {
      auto ptr = reinterpret_cast<const NetSim::DiscoveryBroadcast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageUnion(
        verifier,  values->Get(i), types->GetEnum<MessageUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline const NetSim::NetworkMessage *GetNetworkMessage(const void *buf) {
  return ::flatbuffers::GetRoot<NetSim::NetworkMessage>(buf);
}

inline const NetSim::NetworkMessage *GetSizePrefixedNetworkMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<NetSim::NetworkMessage>(buf);
}

inline bool VerifyNetworkMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NetSim::NetworkMessage>(nullptr);
}

inline bool VerifySizePrefixedNetworkMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NetSim::NetworkMessage>(nullptr);
}

inline void FinishNetworkMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NetSim::NetworkMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedNetworkMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NetSim::NetworkMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace NetSim

#endif  // FLATBUFFERS_GENERATED_GAMESTATE_NETSIM_H_
