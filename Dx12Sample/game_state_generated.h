// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GAMESTATE_PhysicsFlatBuffers_NETWORKING_H_
#define FLATBUFFERS_GENERATED_GAMESTATE_PhysicsFlatBuffers_NETWORKING_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace PhysicsFlatBuffers {
namespace Networking {

struct Vec3;

struct Vec4;

struct GameObjectState;
struct GameObjectStateBuilder;

struct StateUpdate;
struct StateUpdateBuilder;

struct ObjectCreation;
struct ObjectCreationBuilder;

struct PeerJoined;
struct PeerJoinedBuilder;

struct PeerLeft;
struct PeerLeftBuilder;

struct GravityChanged;
struct GravityChangedBuilder;

struct NetMessage;
struct NetMessageBuilder;

enum Message : uint8_t {
  Message_NONE = 0,
  Message_StateUpdate = 1,
  Message_ObjectCreation = 2,
  Message_PeerJoined = 3,
  Message_PeerLeft = 4,
  Message_GravityChanged = 5,
  Message_MIN = Message_NONE,
  Message_MAX = Message_GravityChanged
};

inline const Message (&EnumValuesMessage())[6] {
  static const Message values[] = {
    Message_NONE,
    Message_StateUpdate,
    Message_ObjectCreation,
    Message_PeerJoined,
    Message_PeerLeft,
    Message_GravityChanged
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[7] = {
    "NONE",
    "StateUpdate",
    "ObjectCreation",
    "PeerJoined",
    "PeerLeft",
    "GravityChanged",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (::flatbuffers::IsOutRange(e, Message_NONE, Message_GravityChanged)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<PhysicsFlatBuffers::Networking::StateUpdate> {
  static const Message enum_value = Message_StateUpdate;
};

template<> struct MessageTraits<PhysicsFlatBuffers::Networking::ObjectCreation> {
  static const Message enum_value = Message_ObjectCreation;
};

template<> struct MessageTraits<PhysicsFlatBuffers::Networking::PeerJoined> {
  static const Message enum_value = Message_PeerJoined;
};

template<> struct MessageTraits<PhysicsFlatBuffers::Networking::PeerLeft> {
  static const Message enum_value = Message_PeerLeft;
};

template<> struct MessageTraits<PhysicsFlatBuffers::Networking::GravityChanged> {
  static const Message enum_value = Message_GravityChanged;
};

bool VerifyMessage(::flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        w_(::flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

struct GameObjectState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GameObjectStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_POSITION = 8,
    VT_ROTATION = 10,
    VT_VELOCITY = 12,
    VT_ANGULAR_VELOCITY = 14,
    VT_COLOR = 16
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const PhysicsFlatBuffers::Networking::Vec3 *position() const {
    return GetStruct<const PhysicsFlatBuffers::Networking::Vec3 *>(VT_POSITION);
  }
  const PhysicsFlatBuffers::Networking::Vec4 *rotation() const {
    return GetStruct<const PhysicsFlatBuffers::Networking::Vec4 *>(VT_ROTATION);
  }
  const PhysicsFlatBuffers::Networking::Vec3 *velocity() const {
    return GetStruct<const PhysicsFlatBuffers::Networking::Vec3 *>(VT_VELOCITY);
  }
  const PhysicsFlatBuffers::Networking::Vec3 *angular_velocity() const {
    return GetStruct<const PhysicsFlatBuffers::Networking::Vec3 *>(VT_ANGULAR_VELOCITY);
  }
  const PhysicsFlatBuffers::Networking::Vec4 *color() const {
    return GetStruct<const PhysicsFlatBuffers::Networking::Vec4 *>(VT_COLOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<PhysicsFlatBuffers::Networking::Vec3>(verifier, VT_POSITION, 4) &&
           VerifyField<PhysicsFlatBuffers::Networking::Vec4>(verifier, VT_ROTATION, 4) &&
           VerifyField<PhysicsFlatBuffers::Networking::Vec3>(verifier, VT_VELOCITY, 4) &&
           VerifyField<PhysicsFlatBuffers::Networking::Vec3>(verifier, VT_ANGULAR_VELOCITY, 4) &&
           VerifyField<PhysicsFlatBuffers::Networking::Vec4>(verifier, VT_COLOR, 4) &&
           verifier.EndTable();
  }
};

struct GameObjectStateBuilder {
  typedef GameObjectState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(GameObjectState::VT_ID, id, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GameObjectState::VT_TYPE, type, 0);
  }
  void add_position(const PhysicsFlatBuffers::Networking::Vec3 *position) {
    fbb_.AddStruct(GameObjectState::VT_POSITION, position);
  }
  void add_rotation(const PhysicsFlatBuffers::Networking::Vec4 *rotation) {
    fbb_.AddStruct(GameObjectState::VT_ROTATION, rotation);
  }
  void add_velocity(const PhysicsFlatBuffers::Networking::Vec3 *velocity) {
    fbb_.AddStruct(GameObjectState::VT_VELOCITY, velocity);
  }
  void add_angular_velocity(const PhysicsFlatBuffers::Networking::Vec3 *angular_velocity) {
    fbb_.AddStruct(GameObjectState::VT_ANGULAR_VELOCITY, angular_velocity);
  }
  void add_color(const PhysicsFlatBuffers::Networking::Vec4 *color) {
    fbb_.AddStruct(GameObjectState::VT_COLOR, color);
  }
  explicit GameObjectStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GameObjectState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GameObjectState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GameObjectState> CreateGameObjectState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    int32_t type = 0,
    const PhysicsFlatBuffers::Networking::Vec3 *position = nullptr,
    const PhysicsFlatBuffers::Networking::Vec4 *rotation = nullptr,
    const PhysicsFlatBuffers::Networking::Vec3 *velocity = nullptr,
    const PhysicsFlatBuffers::Networking::Vec3 *angular_velocity = nullptr,
    const PhysicsFlatBuffers::Networking::Vec4 *color = nullptr) {
  GameObjectStateBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_angular_velocity(angular_velocity);
  builder_.add_velocity(velocity);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  builder_.add_type(type);
  builder_.add_id(id);
  return builder_.Finish();
}

struct StateUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StateUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<PhysicsFlatBuffers::Networking::GameObjectState>> *objects() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PhysicsFlatBuffers::Networking::GameObjectState>> *>(VT_OBJECTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.VerifyVector(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           verifier.EndTable();
  }
};

struct StateUpdateBuilder {
  typedef StateUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objects(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PhysicsFlatBuffers::Networking::GameObjectState>>> objects) {
    fbb_.AddOffset(StateUpdate::VT_OBJECTS, objects);
  }
  explicit StateUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StateUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StateUpdate> CreateStateUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PhysicsFlatBuffers::Networking::GameObjectState>>> objects = 0) {
  StateUpdateBuilder builder_(_fbb);
  builder_.add_objects(objects);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StateUpdate> CreateStateUpdateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<PhysicsFlatBuffers::Networking::GameObjectState>> *objects = nullptr) {
  auto objects__ = objects ? _fbb.CreateVector<::flatbuffers::Offset<PhysicsFlatBuffers::Networking::GameObjectState>>(*objects) : 0;
  return PhysicsFlatBuffers::Networking::CreateStateUpdate(
      _fbb,
      objects__);
}

struct ObjectCreation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectCreationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_OBJECT_TYPE = 6,
    VT_INITIAL_POSITION = 8,
    VT_INITIAL_ROTATION = 10,
    VT_INITIAL_SCALE = 12,
    VT_INITIAL_VELOCITY = 14,
    VT_INITIAL_ANGULAR_VELOCITY = 16,
    VT_IS_STATIC = 18,
    VT_SPHERE_RADIUS = 20,
    VT_BOX_SIZE = 22,
    VT_CYLINDER_RADIUS = 24,
    VT_CYLINDER_HEIGHT = 26,
    VT_PLANE_SIZE = 28
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  int32_t object_type() const {
    return GetField<int32_t>(VT_OBJECT_TYPE, 0);
  }
  const PhysicsFlatBuffers::Networking::Vec3 *initial_position() const {
    return GetStruct<const PhysicsFlatBuffers::Networking::Vec3 *>(VT_INITIAL_POSITION);
  }
  const PhysicsFlatBuffers::Networking::Vec4 *initial_rotation() const {
    return GetStruct<const PhysicsFlatBuffers::Networking::Vec4 *>(VT_INITIAL_ROTATION);
  }
  const PhysicsFlatBuffers::Networking::Vec3 *initial_scale() const {
    return GetStruct<const PhysicsFlatBuffers::Networking::Vec3 *>(VT_INITIAL_SCALE);
  }
  const PhysicsFlatBuffers::Networking::Vec3 *initial_velocity() const {
    return GetStruct<const PhysicsFlatBuffers::Networking::Vec3 *>(VT_INITIAL_VELOCITY);
  }
  const PhysicsFlatBuffers::Networking::Vec3 *initial_angular_velocity() const {
    return GetStruct<const PhysicsFlatBuffers::Networking::Vec3 *>(VT_INITIAL_ANGULAR_VELOCITY);
  }
  bool is_static() const {
    return GetField<uint8_t>(VT_IS_STATIC, 0) != 0;
  }
  float sphere_radius() const {
    return GetField<float>(VT_SPHERE_RADIUS, 0.0f);
  }
  const PhysicsFlatBuffers::Networking::Vec3 *box_size() const {
    return GetStruct<const PhysicsFlatBuffers::Networking::Vec3 *>(VT_BOX_SIZE);
  }
  float cylinder_radius() const {
    return GetField<float>(VT_CYLINDER_RADIUS, 0.0f);
  }
  float cylinder_height() const {
    return GetField<float>(VT_CYLINDER_HEIGHT, 0.0f);
  }
  const PhysicsFlatBuffers::Networking::Vec3 *plane_size() const {
    return GetStruct<const PhysicsFlatBuffers::Networking::Vec3 *>(VT_PLANE_SIZE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_OBJECT_TYPE, 4) &&
           VerifyField<PhysicsFlatBuffers::Networking::Vec3>(verifier, VT_INITIAL_POSITION, 4) &&
           VerifyField<PhysicsFlatBuffers::Networking::Vec4>(verifier, VT_INITIAL_ROTATION, 4) &&
           VerifyField<PhysicsFlatBuffers::Networking::Vec3>(verifier, VT_INITIAL_SCALE, 4) &&
           VerifyField<PhysicsFlatBuffers::Networking::Vec3>(verifier, VT_INITIAL_VELOCITY, 4) &&
           VerifyField<PhysicsFlatBuffers::Networking::Vec3>(verifier, VT_INITIAL_ANGULAR_VELOCITY, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_STATIC, 1) &&
           VerifyField<float>(verifier, VT_SPHERE_RADIUS, 4) &&
           VerifyField<PhysicsFlatBuffers::Networking::Vec3>(verifier, VT_BOX_SIZE, 4) &&
           VerifyField<float>(verifier, VT_CYLINDER_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_CYLINDER_HEIGHT, 4) &&
           VerifyField<PhysicsFlatBuffers::Networking::Vec3>(verifier, VT_PLANE_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct ObjectCreationBuilder {
  typedef ObjectCreation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(ObjectCreation::VT_ID, id, 0);
  }
  void add_object_type(int32_t object_type) {
    fbb_.AddElement<int32_t>(ObjectCreation::VT_OBJECT_TYPE, object_type, 0);
  }
  void add_initial_position(const PhysicsFlatBuffers::Networking::Vec3 *initial_position) {
    fbb_.AddStruct(ObjectCreation::VT_INITIAL_POSITION, initial_position);
  }
  void add_initial_rotation(const PhysicsFlatBuffers::Networking::Vec4 *initial_rotation) {
    fbb_.AddStruct(ObjectCreation::VT_INITIAL_ROTATION, initial_rotation);
  }
  void add_initial_scale(const PhysicsFlatBuffers::Networking::Vec3 *initial_scale) {
    fbb_.AddStruct(ObjectCreation::VT_INITIAL_SCALE, initial_scale);
  }
  void add_initial_velocity(const PhysicsFlatBuffers::Networking::Vec3 *initial_velocity) {
    fbb_.AddStruct(ObjectCreation::VT_INITIAL_VELOCITY, initial_velocity);
  }
  void add_initial_angular_velocity(const PhysicsFlatBuffers::Networking::Vec3 *initial_angular_velocity) {
    fbb_.AddStruct(ObjectCreation::VT_INITIAL_ANGULAR_VELOCITY, initial_angular_velocity);
  }
  void add_is_static(bool is_static) {
    fbb_.AddElement<uint8_t>(ObjectCreation::VT_IS_STATIC, static_cast<uint8_t>(is_static), 0);
  }
  void add_sphere_radius(float sphere_radius) {
    fbb_.AddElement<float>(ObjectCreation::VT_SPHERE_RADIUS, sphere_radius, 0.0f);
  }
  void add_box_size(const PhysicsFlatBuffers::Networking::Vec3 *box_size) {
    fbb_.AddStruct(ObjectCreation::VT_BOX_SIZE, box_size);
  }
  void add_cylinder_radius(float cylinder_radius) {
    fbb_.AddElement<float>(ObjectCreation::VT_CYLINDER_RADIUS, cylinder_radius, 0.0f);
  }
  void add_cylinder_height(float cylinder_height) {
    fbb_.AddElement<float>(ObjectCreation::VT_CYLINDER_HEIGHT, cylinder_height, 0.0f);
  }
  void add_plane_size(const PhysicsFlatBuffers::Networking::Vec3 *plane_size) {
    fbb_.AddStruct(ObjectCreation::VT_PLANE_SIZE, plane_size);
  }
  explicit ObjectCreationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectCreation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectCreation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectCreation> CreateObjectCreation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    int32_t object_type = 0,
    const PhysicsFlatBuffers::Networking::Vec3 *initial_position = nullptr,
    const PhysicsFlatBuffers::Networking::Vec4 *initial_rotation = nullptr,
    const PhysicsFlatBuffers::Networking::Vec3 *initial_scale = nullptr,
    const PhysicsFlatBuffers::Networking::Vec3 *initial_velocity = nullptr,
    const PhysicsFlatBuffers::Networking::Vec3 *initial_angular_velocity = nullptr,
    bool is_static = false,
    float sphere_radius = 0.0f,
    const PhysicsFlatBuffers::Networking::Vec3 *box_size = nullptr,
    float cylinder_radius = 0.0f,
    float cylinder_height = 0.0f,
    const PhysicsFlatBuffers::Networking::Vec3 *plane_size = nullptr) {
  ObjectCreationBuilder builder_(_fbb);
  builder_.add_plane_size(plane_size);
  builder_.add_cylinder_height(cylinder_height);
  builder_.add_cylinder_radius(cylinder_radius);
  builder_.add_box_size(box_size);
  builder_.add_sphere_radius(sphere_radius);
  builder_.add_initial_angular_velocity(initial_angular_velocity);
  builder_.add_initial_velocity(initial_velocity);
  builder_.add_initial_scale(initial_scale);
  builder_.add_initial_rotation(initial_rotation);
  builder_.add_initial_position(initial_position);
  builder_.add_object_type(object_type);
  builder_.add_id(id);
  builder_.add_is_static(is_static);
  return builder_.Finish();
}

struct PeerJoined FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PeerJoinedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEER_ID = 4
  };
  uint32_t peer_id() const {
    return GetField<uint32_t>(VT_PEER_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PEER_ID, 4) &&
           verifier.EndTable();
  }
};

struct PeerJoinedBuilder {
  typedef PeerJoined Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_peer_id(uint32_t peer_id) {
    fbb_.AddElement<uint32_t>(PeerJoined::VT_PEER_ID, peer_id, 0);
  }
  explicit PeerJoinedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PeerJoined> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PeerJoined>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PeerJoined> CreatePeerJoined(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t peer_id = 0) {
  PeerJoinedBuilder builder_(_fbb);
  builder_.add_peer_id(peer_id);
  return builder_.Finish();
}

struct PeerLeft FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PeerLeftBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEER_ID = 4
  };
  uint32_t peer_id() const {
    return GetField<uint32_t>(VT_PEER_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PEER_ID, 4) &&
           verifier.EndTable();
  }
};

struct PeerLeftBuilder {
  typedef PeerLeft Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_peer_id(uint32_t peer_id) {
    fbb_.AddElement<uint32_t>(PeerLeft::VT_PEER_ID, peer_id, 0);
  }
  explicit PeerLeftBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PeerLeft> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PeerLeft>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PeerLeft> CreatePeerLeft(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t peer_id = 0) {
  PeerLeftBuilder builder_(_fbb);
  builder_.add_peer_id(peer_id);
  return builder_.Finish();
}

struct GravityChanged FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GravityChangedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEW_GRAVITY = 4
  };
  const PhysicsFlatBuffers::Networking::Vec3 *new_gravity() const {
    return GetStruct<const PhysicsFlatBuffers::Networking::Vec3 *>(VT_NEW_GRAVITY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<PhysicsFlatBuffers::Networking::Vec3>(verifier, VT_NEW_GRAVITY, 4) &&
           verifier.EndTable();
  }
};

struct GravityChangedBuilder {
  typedef GravityChanged Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_new_gravity(const PhysicsFlatBuffers::Networking::Vec3 *new_gravity) {
    fbb_.AddStruct(GravityChanged::VT_NEW_GRAVITY, new_gravity);
  }
  explicit GravityChangedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GravityChanged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GravityChanged>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GravityChanged> CreateGravityChanged(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const PhysicsFlatBuffers::Networking::Vec3 *new_gravity = nullptr) {
  GravityChangedBuilder builder_(_fbb);
  builder_.add_new_gravity(new_gravity);
  return builder_.Finish();
}

struct NetMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE_TYPE = 4,
    VT_MESSAGE_TYPE = 6
  };
  PhysicsFlatBuffers::Networking::Message message_type_type() const {
    return static_cast<PhysicsFlatBuffers::Networking::Message>(GetField<uint8_t>(VT_MESSAGE_TYPE_TYPE, 0));
  }
  const void *message_type() const {
    return GetPointer<const void *>(VT_MESSAGE_TYPE);
  }
  template<typename T> const T *message_type_as() const;
  const PhysicsFlatBuffers::Networking::StateUpdate *message_type_as_StateUpdate() const {
    return message_type_type() == PhysicsFlatBuffers::Networking::Message_StateUpdate ? static_cast<const PhysicsFlatBuffers::Networking::StateUpdate *>(message_type()) : nullptr;
  }
  const PhysicsFlatBuffers::Networking::ObjectCreation *message_type_as_ObjectCreation() const {
    return message_type_type() == PhysicsFlatBuffers::Networking::Message_ObjectCreation ? static_cast<const PhysicsFlatBuffers::Networking::ObjectCreation *>(message_type()) : nullptr;
  }
  const PhysicsFlatBuffers::Networking::PeerJoined *message_type_as_PeerJoined() const {
    return message_type_type() == PhysicsFlatBuffers::Networking::Message_PeerJoined ? static_cast<const PhysicsFlatBuffers::Networking::PeerJoined *>(message_type()) : nullptr;
  }
  const PhysicsFlatBuffers::Networking::PeerLeft *message_type_as_PeerLeft() const {
    return message_type_type() == PhysicsFlatBuffers::Networking::Message_PeerLeft ? static_cast<const PhysicsFlatBuffers::Networking::PeerLeft *>(message_type()) : nullptr;
  }
  const PhysicsFlatBuffers::Networking::GravityChanged *message_type_as_GravityChanged() const {
    return message_type_type() == PhysicsFlatBuffers::Networking::Message_GravityChanged ? static_cast<const PhysicsFlatBuffers::Networking::GravityChanged *>(message_type()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE_TYPE) &&
           VerifyMessage(verifier, message_type(), message_type_type()) &&
           verifier.EndTable();
  }
};

template<> inline const PhysicsFlatBuffers::Networking::StateUpdate *NetMessage::message_type_as<PhysicsFlatBuffers::Networking::StateUpdate>() const {
  return message_type_as_StateUpdate();
}

template<> inline const PhysicsFlatBuffers::Networking::ObjectCreation *NetMessage::message_type_as<PhysicsFlatBuffers::Networking::ObjectCreation>() const {
  return message_type_as_ObjectCreation();
}

template<> inline const PhysicsFlatBuffers::Networking::PeerJoined *NetMessage::message_type_as<PhysicsFlatBuffers::Networking::PeerJoined>() const {
  return message_type_as_PeerJoined();
}

template<> inline const PhysicsFlatBuffers::Networking::PeerLeft *NetMessage::message_type_as<PhysicsFlatBuffers::Networking::PeerLeft>() const {
  return message_type_as_PeerLeft();
}

template<> inline const PhysicsFlatBuffers::Networking::GravityChanged *NetMessage::message_type_as<PhysicsFlatBuffers::Networking::GravityChanged>() const {
  return message_type_as_GravityChanged();
}

struct NetMessageBuilder {
  typedef NetMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message_type_type(PhysicsFlatBuffers::Networking::Message message_type_type) {
    fbb_.AddElement<uint8_t>(NetMessage::VT_MESSAGE_TYPE_TYPE, static_cast<uint8_t>(message_type_type), 0);
  }
  void add_message_type(::flatbuffers::Offset<void> message_type) {
    fbb_.AddOffset(NetMessage::VT_MESSAGE_TYPE, message_type);
  }
  explicit NetMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMessage> CreateNetMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    PhysicsFlatBuffers::Networking::Message message_type_type = PhysicsFlatBuffers::Networking::Message_NONE,
    ::flatbuffers::Offset<void> message_type = 0) {
  NetMessageBuilder builder_(_fbb);
  builder_.add_message_type(message_type);
  builder_.add_message_type_type(message_type_type);
  return builder_.Finish();
}

inline bool VerifyMessage(::flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_StateUpdate: {
      auto ptr = reinterpret_cast<const PhysicsFlatBuffers::Networking::StateUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_ObjectCreation: {
      auto ptr = reinterpret_cast<const PhysicsFlatBuffers::Networking::ObjectCreation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_PeerJoined: {
      auto ptr = reinterpret_cast<const PhysicsFlatBuffers::Networking::PeerJoined *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_PeerLeft: {
      auto ptr = reinterpret_cast<const PhysicsFlatBuffers::Networking::PeerLeft *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_GravityChanged: {
      auto ptr = reinterpret_cast<const PhysicsFlatBuffers::Networking::GravityChanged *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline const PhysicsFlatBuffers::Networking::NetMessage *GetNetMessage(const void *buf) {
  return ::flatbuffers::GetRoot<PhysicsFlatBuffers::Networking::NetMessage>(buf);
}

inline const PhysicsFlatBuffers::Networking::NetMessage *GetSizePrefixedNetMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<PhysicsFlatBuffers::Networking::NetMessage>(buf);
}

inline bool VerifyNetMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<PhysicsFlatBuffers::Networking::NetMessage>(nullptr);
}

inline bool VerifySizePrefixedNetMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<PhysicsFlatBuffers::Networking::NetMessage>(nullptr);
}

inline void FinishNetMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PhysicsFlatBuffers::Networking::NetMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedNetMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PhysicsFlatBuffers::Networking::NetMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Networking
}  // namespace PhysicsFlatBuffers

#endif  // FLATBUFFERS_GENERATED_GAMESTATE_PhysicsFlatBuffers_NETWORKING_H_
